package querycute

// OptionFunc configure query
type OptionFunc func(q *Query) error

// Query object
type Query struct {
	Error error

	tx      sql.Tx
	ctx     context.Context
	values  []interface{}
	mapping *Mapping
	m
}

// New query instance
func New(m Mapper, options ...OptionFunc) *Query {
	mapping, values := m.GetMapping()
	q := &Query{
		values:  values,
		mapping: mapping,
		m:       m,
	}

	for i := range options {
		if q.Error = options[i](q); q.Error != nil {
			break
		}
	}

	return q
}

// wrap each query function, is mandatory
func (q *Query) wrap(f func() error) (err error) {
	var tx *sql.Tx
	if q.tx == nil {
		if q.tx, err = DB.Begin(); err != nil {
			return err
		}
		tx = q.tx
	}

	var cancel context.CancelFunc
	if q.ctx == nil {
		q.ctx, cancel = context.WithCancel(context.Background())
	}

	if err := f(); err != nil {
		return err
	}

	if tx != nil {
		if err := tx.Commit(); err != nil {
			return err
		}
	}

	if cancel != nil {
		cancel()
	}

	if v, ok := q.m.(ValuesBinder); ok {
		if err := v.OnValuesBind(q.mapping.Fields, q.values); err != nil {
			return err
		}
	}
	return nil
}

// SelectByID model instance
func (q *Query) SelectByID(id interface{}) error {
	return q.wrap(func() error {
		query := `SELECT ` +
			strings.Join(q.mapping.Fields, ", ") +
			` FROM ` + q.mapping.Table +
			` WHERE id = $1 LIMIT 1`

		rows, err := q.tx.QueryContext(q.ctx, query, id)
		if err != nil {
			return err
		}
		defer rows.Close()

		if !rows.Next() {
			return ErrNotFound
		}

		return rows.Scan(q.values...)
	})
}

// Insert object to database, id param can be nill, in that case id field will not be included into query and it's
// value generation should be defined in table field schema (for example as serial value)
func (q *Query) Insert(id interface{}) error {
	return q.wrap(func() error {
		// if id is not declared, it should be generated by database, and we use in request all fields except first (id)
		// else if id parameter defined, we include all field names in query
		values = q.values[1:]
		getFieldsFromIndex := 1
		if id != nil {
			getFieldsFromIndex = 0
			// we use param id value, not object value
			values = append([]interface{}{id}, q.values...)
		}

		q := `INSERT INTO ` + q.mapping.Table + ` (`
		q += strings.Join(q.mapping.Fields[getFieldsFromIndex:], ", ")
		q += `) VALUES (`
		params := make([]string, len(q.mapping.Fields[getFieldsFromIndex:]))
		for i := range q.mapping.Fields[getFieldsFromIndex:] {
			params[i] = "$" + strconv.Itoa(i+1)
		}
		q += strings.Join(params, ", ")
		q += ")"

		_, err := q.tx.Exec(q, values...)
		return err
	})
}

// Update object
func (q *Query) Update() error {
	return q.wrap(func() error {
		names := make([]string, len(q.mapping.Fields))
		q := `UPDATE ` + q.mapping.Table + ` SET `
		for i, field := range q.mapping.Fields {
			names[i] = field + " = $" + strconv.Itoa(i+1)
		}
		q += strings.Join(names, ", ")
		q += ` WHERE id = $` + strconv.Itoa(len(q.mapping.Fields)+1)
		_, err := db.Default.Exec(q, append(q.values, values[0])...)
		return err
	})
}
