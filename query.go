package querycute

import (
	"context"
	"database/sql"
	"strconv"
	"strings"
)

// Query object
type Query struct {
	Error error

	tx      *sql.Tx
	ctx     context.Context
	values  []interface{}
	mapping Mapping
	m       Mapper
}

// New query instance
func New(m Mapper, options ...OptionFunc) *Query {
	mapping, values := m.GetMapping()
	q := &Query{
		values:  values,
		mapping: mapping,
		m:       m,
	}

	for i := range options {
		if q.Error = options[i](q); q.Error != nil {
			break
		}
	}

	return q
}

// wrap each query function, is mandatory
func (q *Query) wrap(f func() error) (err error) {
	var tx *sql.Tx
	// init transaction if it was not set
	if q.tx == nil {
		if q.tx, err = DB.Begin(); err != nil {
			return err
		}
		tx = q.tx
	}

	// init internal context if it was not set
	var cancel context.CancelFunc
	if q.ctx == nil {
		q.ctx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}

	// do query
	if err := f(); err != nil {
		return err
	}

	// if transaction was set by us, commit them, else don't tuch
	if tx != nil {
		if err := tx.Commit(); err != nil {
			return err
		}
	}

	if cancel != nil {
		cancel()
	}

	if v, ok := q.m.(ValuesBinder); ok {
		if err := v.OnValuesBind(q.mapping.Fields, q.values); err != nil {
			return err
		}
	}
	return nil
}

// SelectByID model instance
func (q *Query) SelectByID(id interface{}) error {
	return q.wrap(func() error {
		query := `SELECT ` +
			strings.Join(q.mapping.Fields, ", ") +
			` FROM "` + q.mapping.Table +
			`" WHERE id = $1 LIMIT 1`

		rows, err := q.tx.QueryContext(q.ctx, query, id)
		if err != nil {
			return err
		}
		defer rows.Close()

		if !rows.Next() {
			return ErrNotFound
		}

		return rows.Scan(q.values...)
	})
}

// Insert object to database, id param can be nill, in that case id field will not be included into query and it's
// value generation should be defined in table field schema (for example as serial value)
func (q *Query) Insert(id interface{}) error {
	return q.wrap(func() (err error) {
		// if id is not declared, it should be generated by database, and we use in request all fields except first (id)
		// else if id parameter defined, we include all field names in query
		values := q.values[1:]
		getFieldsFromIndex := 1
		if id != nil {
			getFieldsFromIndex = 0
			// we use param id value, not object value
			values = append([]interface{}{&id}, values...)
		}

		s := `INSERT INTO "` + q.mapping.Table + `" (`
		s += strings.Join(q.mapping.Fields[getFieldsFromIndex:], ", ")
		s += `) VALUES (`
		params := make([]string, len(q.mapping.Fields[getFieldsFromIndex:]))
		for i := range q.mapping.Fields[getFieldsFromIndex:] {
			params[i] = "$" + strconv.Itoa(i+1)
		}
		s += strings.Join(params, ", ")
		s += ")"

		if id == nil {
			s += " RETURNING id"
		}

		if id == nil {
			return q.tx.QueryRowContext(q.ctx, s, values...).Scan(q.values[0])
		}
		_, err = q.tx.ExecContext(q.ctx, s, values...)
		return
	})
}

// Update object
func (q *Query) Update() error {
	return q.wrap(func() error {
		names := make([]string, len(q.mapping.Fields))
		s := `UPDATE "` + q.mapping.Table + `" SET `
		for i, field := range q.mapping.Fields {
			names[i] = field + " = $" + strconv.Itoa(i+1)
		}
		s += strings.Join(names, ", ")
		s += ` WHERE id = $` + strconv.Itoa(len(q.mapping.Fields)+1)
		_, err := q.tx.Exec(s, append(q.values, q.values[0])...)
		return err
	})
}
